//백준 [연구소]
// dfs, bfs
// 항상 확실하지 않은 곳은 print로 확인하는 습관을 들이자
// 한번에 완성하고 찾으려고 하면 찾기 힘들 수 있다.
#include<iostream>
#include<vector>
#include<queue>

using namespace std;
int N, M;
int Map[10][10];
bool visited[10][10];
int dx[]={0,0,-1,1};
int dy[]={-1,1,0,0};
int NUM = 0;
vector<pair<int,int>> virus; //행 열
queue<pair<int, int>> sv;
vector<int> wall;
int sol=0;
void cal(){
    
    int n=0;
    for(int r=0; r<N;r++){
        for(int c=0; c<M; c++){
            if(visited[r][c] == true){
                n++;
            }
            visited[r][c]=false; //초기화
        }
    }
    if(sol < NUM - n){
        sol = NUM-n;
    }
}
void bfs(){
    for(int i=0; i<virus.size(); i++){
        visited[virus[i].first][virus[i].second] = true;
        sv.push(make_pair(virus[i].first,virus[i].second ));
    }
    while(!sv.empty()){
        pair<int,int> t = sv.front();
        sv.pop();
        for(int d=0; d<4 ;d++){
            int nx = t.second + dx[d];
            int ny = t.first + dy[d];
            if(0<=nx && nx<M && 0<=ny && ny<N && Map[ny][nx]==0 &&
               visited[ny][nx]== false){
                visited[ny][nx]= true;
                sv.push(make_pair(ny,nx));
            }
        }
    }
    cal();
}
void dfs(int selected, int depth){
    if(depth <= N*M){
        if(selected ==3){
            
            for(int k=0; k<3; k++){
                Map[wall[k]/M][wall[k] %M]=1;
            }
            bfs();
            for(int k=0; k<3; k++){
                Map[wall[k] /M][wall[k] %M]=0;
            }
            
        }else{
            if(Map[depth/M][depth%M]==0){
                wall.push_back(depth);
                dfs(selected+1, depth+1);
                wall.pop_back();
            }
            dfs(selected, depth+1);
        }
    }
}
int main(){
    cin >> N >> M;
    int num=0;
    for(int r=0; r<N; r++){
        for(int c=0; c<M; c++){
            cin >> Map[r][c];
            if(Map[r][c] == 2){
                virus.push_back(make_pair(r,c));
            }else if(Map[r][c]==1){
                num++;
            }
        }
    }
    NUM = N*M-num-3;
    dfs(0,0);
    
    cout << sol;
    return 0;
}