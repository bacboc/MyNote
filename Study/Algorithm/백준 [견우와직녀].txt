//백준 [견우와직녀]
// BFS , 문제 잘 읽자

#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int N,M;
int map[11][11];
bool visited[11][11]={false,};
int dx[]={0,-1,0,1};
int dy[]={-1,0,1,0};
struct node{
    int x, y, time,cnt;
    node(int x, int y,int time,int cnt):x(x), y(y), time(time), cnt(cnt){}
};
vector<node> V;
queue<node> Q;
int mv = 987654321;
void print(){
    for(int r=0; r<N; r++){
        for(int c=0; c<N; c++){
            cout << map[r][c] << " ";
        }cout << "\n";
    }cout <<"\n";
}

int main(){
        cin >> N >> M;
        for(int r=0; r<N; r++){
            for(int c=0; c<N; c++){
                cin >> map[r][c];
            }
        }
        int f = true;
        for(int r=0; r<N; r++){
            for(int c=0; c<N; c++){
                if(map[r][c]==0){
                    for(int d=0; d<4; d++){
                        if(0<=r+dy[d]&&r+dy[d]<N&&0<=c+dx[d] &&c+dx[d]<N){
                            int dd=(d+1)%4;
                            if(map[r+dy[d]][c+dx[d]]==0){
                                if(0<=r+dy[dd]&&r+dy[dd]<N&&0<=c+dx[dd] &&c+dx[dd]<N){
                                        if(map[r+dy[dd]][c+dx[dd]]==0){
                                            f = false;
                                        }
                                }
                            }
                        }
                    }
                    
                    if(f){
                        V.push_back(node(c,r,0,0));
                    }
                    f=true;
                }
            }
        }
        
        
        for(int k =0 ; k< V.size(); k++){  //절벽중에 하나 선택해서 다리 놓기
            node tnode = V[k];
            map[tnode.y][tnode.x] = M; //다리 건설
            Q.push(node(0,0,0,0));
            while(!Q.empty()){  //BFS
                node temp = Q.front();
                Q.pop();
                if(temp.x == N-1 && temp.y == N-1){ //SOL
                    if(mv > temp.time){
                        mv=temp.time;
                    }
                    while(!Q.empty()){
                        Q.pop();
                    }
                    break;
                }
                for(int d=0; d<4; d++){ // 4방향 탐색
                    int nx = temp.x + dx[d];
                    int ny = temp.y + dy[d];
                    if(0<=nx && nx < N && 0<=ny && ny<N){
                        if(map[ny][nx]==1 && visited[ny][nx]==false){
                            visited[ny][nx] = true;
                            Q.push(node(nx,ny,temp.time+1,0));
                        }
                        if(map[ny][nx]>1 &&(temp.time+1)%map[ny][nx]==0&&visited[ny][nx]==false ){
                            if(temp.cnt!=1){
                                visited[ny][nx] = true;
                                Q.push(node(nx,ny,temp.time+1,1));
                            }

                        }
                    }
                }
                
                bool flag = false;
                for(int d=0; d<4; d++){ //주위에 다리가 있는지 본다. + 누가 지나간 흔적이 있으면 안간다.
                    int nx = temp.x + dx[d];
                    int ny = temp.y + dy[d];
                    if(0<=nx && nx < N && 0<=ny && ny<N && map[ny][nx]>1){
                        if(visited[ny][nx] == false){
                            flag = true;
                        }
                    }
                }
                if(flag){ //있으면 대기한다.
                    Q.push(node(temp.x,temp.y,temp.time+1,temp.cnt));
                }
            
            }
            map[tnode.y][tnode.x] = 0;
            for(int r=0; r<N; r++){
                for(int c=0; c<N; c++){
                    visited[r][c]=false;
                }
            }visited[0][0]=true;
        }
        cout <<mv<<"\n";
        mv=987654321;
        V.clear();
        while(!Q.empty()){
            Q.pop();
        }
    
    return 0;
}
