//SWEA [줄기세포배양]
// BFS
// 문제 꼼꼼히 잘 읽으세요 ... 제발 ㅠㅠ

#include<iostream>
#include<queue>
#include<vector>
using namespace std;
int dx[]= {0,0,-1,1};
int dy[]= {-1,1,0,0};
int Map[651][651]={0,};
bool visited[651][651]={false,};
int N,M,K;
struct node{
    int x, y, t, l;
    node(){}
    node(int x, int y, int t, int l): x(x), y(y),t(t), l(l) {}
};
queue<node> cell;
queue<int> active;
int num =0;

void bfs(){
    int size = (int)cell.size();
    num=0;
    for(int s=0; s<size; s++){
        node temp = cell.front();
        cell.pop();
        temp.l= temp.l-1;
        if(temp.l >=0){
            cell.push(node(temp.x, temp.y, temp.t, temp.l));
        }else{
            if(temp.t>1)
                active.push(temp.t);
            
            for(int d=0; d<4; d++){
                int nx = temp.x + dx[d];
                int ny = temp.y + dy[d];
                if(nx >= 651 || nx<0 || ny >=651 || ny<0){
                    continue;
                }
                if(visited[ny][nx]==false){
                    if(Map[ny][nx] < temp.t){
                        Map[ny][nx] = temp.t;
                        cell.push(node(nx,ny, temp.t,temp.t));
                    }
                }
            }
        }
    }
    size = (int)cell.size();
    for(int s=0; s<size; s++){
        node tem = cell.front();
        cell.pop();
        if(tem.t != Map[tem.y][tem.x]){ // 충돌 걸러내기
            continue;
        }
        visited[tem.y][tem.x]=true;
        cell.push(node(tem.x,tem.y,tem.t,tem.l));
    }
    size = (int)active.size();
    for(int s=0; s<size; s++){
        int ntemp = active.front();
        active.pop();
        ntemp--;
        if(ntemp>0){
            active.push(ntemp);
        }
    }
    
}

int main(){
    int T;
    cin >>T;
    for(int test_case=0; test_case< T; test_case++){
        cin >> N >> M >> K;
        for(int r=300; r < 300+N; r++){
            for(int c=300; c<300+M; c++){
                cin >>Map[r][c];
                if(Map[r][c]!=0){
                    visited[r][c] = true;
                    cell.push(node(c,r,Map[r][c], Map[r][c]));
                }
            }
        }
        for(int k=0; k <K; k++){ // k초
            bfs();
        }
        cout <<"#"<<test_case+1<<" "<<cell.size() + active.size()<<"\n";
        
        // 초기화 해야한다.
        num=0;
        for(int r=0; r < 651; r++){
            for(int c=0; c<651; c++){
                Map[r][c]=0;
                visited[r][c] =false;
            }
        }
        while(!cell.empty()){
            cell.pop();
        }
        while(!active.empty()){
            active.pop();
        }
    }
    return 0;
}
