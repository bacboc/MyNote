// SWEA [벽돌깨기]
// 순열

#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
int N, W, H;
int Map[16][13];
int dx[] = { 0,0,-1,1 };
int dy[] = { -1,1,0,0 };
int MN = 99999;
struct node {
    int x, y, num;
    node() {}
    node(int x, int y, int num) : x(x), y(y), num(num) {}
};
queue<node> Q;
void print() {
    cout << "\n";
    for (int r = 0; r < H; r++) {
        for (int c = 0; c < W; c++) {
            cout << Map[r][c] << " ";
        }cout << "\n";
    }cout << "\n";
}
void solution() {
    int num = 0;
    for (int r = 0; r < H; r++) {
        for (int c = 0; c < W; c++) {
            if (Map[r][c] !=0 ) {
                num++;
            }
        }
    }
    if (MN > num) {
        MN = num;
    }
}
void reorga() {
    queue<int> temp;
    for (int c = 0; c < W; c++) {
        for (int r = H-1; r >= 0; r--) {
            if (Map[r][c] != 0) {
                temp.push(Map[r][c]);
            }
        }
        for (int r = H-1; r >= 0; r--) {
            if (!temp.empty()) {
                Map[r][c] = temp.front();
                temp.pop();
            }
            else {
                Map[r][c] = 0;
            }
        }
    }
}
 
void crush() {
    while (!Q.empty()) {
        node ori = Q.front();
        node temp;
        Q.pop();
        Map[ori.y][ori.x] = 0;
        for (int d = 0; d < 4; d++) {
            temp.x = ori.x;
            temp.y = ori.y;
            for (int k = 1; k < ori.num; k++) {
                if (0 <= temp.x + dx[d] && temp.x + dx[d] < W && 0 <= temp.y + dy[d] && temp.y + dy[d] < H) {
                    temp.x = temp.x + dx[d];
                    temp.y = temp.y + dy[d];
                    if (Map[temp.y][temp.x] <= 1) {
                        Map[temp.y][temp.x] = 0;
                    }
                    else {
                        Q.push(node(temp.x, temp.y, Map[temp.y][temp.x]));
                        Map[temp.y][temp.x] = 0;
                    }
                }
            }
        }
    }
}
 
void cal(int s) {
    for (int r = 0; r < H; r++) {
        if (Map[r][s] == 1) {
            Map[r][s] = 0;
            return;
        }
        else if (Map[r][s] > 1) {
            Q.push(node(s, r, Map[r][s]));
            break;
        }
    }
    if (!Q.empty()) {
        crush();
        reorga();
    }
}
 
void dfs(int depth) {
        if (depth == N) {
            //cal
            solution();
             
        }
        else {
            int temp_map[16][13];
            for (int r = 0; r < H; r++) {
                for (int c = 0; c < W; c++) {
                    temp_map[r][c] = Map[r][c];
                }
            }
            for (int s = 0; s < W; s++) {
                cal(s);
                dfs(depth + 1);
                for (int r = 0; r < H; r++) {
                    for (int c = 0; c < W; c++) {
                        Map[r][c] = temp_map[r][c];
                    }
                }
            }
        }
}
int main() {
    int T;
    cin >> T;
    for (int t = 1; t <= T; t++) {
        cin >> N >> W >> H;
         
        for (int h = 0; h < H; h++) {
            for (int w = 0; w < W; w++) {
                cin >> Map[h][w];
            }
        }
        dfs(0);
        cout << "#"<<t <<" " << MN<<"\n";
        //초기화
        MN = 99999;
        while (!Q.empty()) {
            Q.pop();
        }
    }
 
    return 0;
}