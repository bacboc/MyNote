// 백준 [게임]
// visited 가 true 인 곳에 가면 -1 출력하면 될듯
// DFS와 DP를 결합한 문제인데.. 답을 찾아봄
// DP이런식으로 쓰는구나
// int& 와 int 에 대해서 공부하자

#include<iostream>
#include<algorithm>
using namespace std;
int N, M;
int map[51][51];
int dp[51][51]={0,};
bool visited[51][51];
int dx[]= {0,0,-1,1};
int dy[]= {-1,1,0,0};
int max_num=0;
void print(){
    cout << "\n";
    for(int r=0; r<N; r++){
        for(int c=0; c<M; c++){
            cout << dp[r][c] << " ";
        }cout << "\n";
    }cout << "\n";
}

int dfs(int x, int y){
    if( !(0<=x && x < M && 0<=y && y<N) || map[y][x] >10){
        return 0;
    }
    if(visited[y][x]==true){
        cout << -1 << "\n";
        //return -1;
        exit(0);
    }
    
    //int& num = dp[y][x];
    if(dp[y][x] != -1) return dp[y][x];
    
    visited[y][x]=true;
    int mul = map[y][x];
    for(int d=0; d<4; d++){
        int nx = x+dx[d]*mul;
        int ny = y+dy[d]*mul;
        dp[y][x] = max(dp[y][x], dfs(nx, ny)+1);
    }
    visited[y][x]=false;
    return dp[y][x];
}
int main(){
    std::ios::sync_with_stdio(false);
    cin >>N >>M;
    string temp_str;
    for(int r=0; r<N; r++){
        cin >> temp_str;
        for(int c=0; c<M; c++){
            map[r][c] = temp_str[c] - '0';
            dp[r][c]=-1;
        }
    }
    //dp[0][0]=1;
    dfs(0,0);
    print();
    cout << dfs(0,0)<<"\n";
    return 0;
}