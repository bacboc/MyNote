//https://www.acmicpc.net/problem/1520
// DFS + DP
#include <iostream>
using namespace std;
int R, C;
int map[500][500];
bool visited[500][500];
unsigned int sol=0;
int d_x[]={0,0,-1,1};
int d_y[]={-1,1,0,0};
int dp[500][500];

bool search(int y, int x, int d){
    if( 0<= x + d_x[d]&& x + d_x[d]<C && 0<=y+d_y[d]&&y+d_y[d]<R
       &&visited[y+d_y[d]][x+d_x[d]]==false){
        if( map[y][x] > map[y+d_y[d]][x+d_x[d]] ){
            visited[y+d_y[d]][x+d_x[d]]=true;
            return true;
        }
    }
    return false;
};

int dfs(int y, int x){
    if(y==R-1 && x==C-1){
        sol++;
        return 1;
    }
    if(dp[y][x] != -1){ // 이미 있는 길이라면 
        return dp[y][x];
    }
    
    int s=0;
    for(int d=0; d < 4; d++){
        if(search(y,x,d)){ //이동 가능하면
            s += dfs(y+d_y[d], x+d_x[d]); // move
            visited[y+d_y[d]][x+d_x[d]]=false; // recover
        }
    }
    dp[y][x] = s;
    return dp[y][x];
}
int main(){
    cin >> R >> C;
    for(int r=0; r<R; r++){
        for(int c=0; c<C; c++){
            cin >> map[r][c];
            visited[r][c]=false;
            dp[r][c]=-1;
        }
    }
    visited[0][0]=true;
    
    cout << dfs(0,0);
    //initialize
    sol=0;
    return 0;
}
