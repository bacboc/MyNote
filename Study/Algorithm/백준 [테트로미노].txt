//백준 [테트로미노]
// dfs
// visited를 빼는 실수를 했다.
// 틀린 테스트케이스를 찾는 방법을 잘 터득하자!
// -> 극단적인 입력 넣어보기 , 각 모양의 마지막 경우에 잘 맞아 떨어지는지 확인하다가 발견하게 되었다. ㅓ 이 모양이 문제였다.

#include<iostream>
#include<vector>
using namespace std;
int N, M;
int Map[501][501];
int Max = 0 ;
int dx[]= {0,0,-1,1};
int dy[]={-1,1,0,0};
bool visited[501][501];

void dfs(int y, int x,int sum,int depth){
    if(depth==3 ){
        if(Max<sum){
            Max = sum ;
        }
    }else{
        for(int d=0; d<4; d++){
            if(0<=x+dx[d] && x+dx[d]<M &&0<=y+dy[d]&&y+dy[d]<N &&
               visited[y+dy[d]][x+dx[d]]==false){
                visited[y+dy[d]][x+dx[d]]=true;
                dfs(y+dy[d],x+dx[d], sum + Map[y+dy[d]][x+dx[d]], depth+1);
                visited[y+dy[d]][x+dx[d]]=false;
            }
        }
    }
}

void search(){
    for(int r=0; r<N; r++){
        for(int c=0; c<M; c++){
            if(r+2 < N && c+1 <M){
                if(Max <Map[r][c]+Map[r+1][c]+Map[r+2][c]+Map[r+1][c+1]){
                    Max=Map[r][c]+Map[r+1][c]+Map[r+2][c]+Map[r+1][c+1];
                }
            }
            if(r+1 < N && c+2 <M){
                if(Max <Map[r][c]+Map[r][c+1]+Map[r][c+2]+Map[r+1][c+1]){
                    Max=Map[r][c]+Map[r][c+1]+Map[r][c+2]+Map[r+1][c+1];
                }
            }
            if(r+1 < N && c+2 <M){
                if(Max <Map[r][c+1]+Map[r+1][c]+Map[r+1][c+1]+Map[r+1][c+2]){
                    Max=Map[r][c+1]+Map[r+1][c]+Map[r+1][c+1]+Map[r+1][c+2];
                }
            }
            if(r+2 < N && c+1 <M){
                if(Max <Map[r+1][c]+Map[r][c+1]+Map[r+1][c+1]+Map[r+2][c+1]){
                    Max=Map[r+1][c]+Map[r][c+1]+Map[r+1][c+1]+Map[r+2][c+1];
                }
            }
        }
    }
}

int main(){
    cin >> N >> M;
    for(int r=0; r<N; r++){
        for(int c=0; c<M; c++){
            cin >> Map[r][c];
        }
    }
    for(int r=0; r<N; r++){
        for(int c=0; c< M; c++){
            visited[r][c]=true;
            dfs(r,c,Map[r][c],0);
            visited[r][c]=false;
        }
    }
    search();
    
    cout << Max;
    return 0;
}