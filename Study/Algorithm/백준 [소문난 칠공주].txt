//백준 [소문난 칠공주]
//조합 (DFS) + 검색(BFS) 문제
// 25개중 랜덤으로 7개를 뽑아서 검색을 하는 형식으로 하였다.
//설마설마 했는데 이 방법이 전부였다.
// 중간에 틀렸는데 이유는 DFS상에서 depth제한을 잘못했다. 실수를 줄여야한다.
// 배운점 : 극단적인 테스트케이스를 넣어보자

#include<iostream>
#include<string>
#include<vector>
#include<queue>
using namespace std;
int MAP[5][5];
bool visited[5][5]={false,};
int dx[]= {0,0,-1,1};
int dy[]= {-1,1,0,0};
int sol=0;
void print(){
    cout << "\n";
    for(int r=0; r<5; r++){
        for(int c=0; c<5; c++){
            cout << visited[r][c] << " ";
        }cout << "\n";
    }cout << "\n";
}
vector<int> seven;
queue<int> Q;
void cal(){
    bool check[7] = {false,};
    Q.push(seven[0]);
    check[0] = true;
    int cnt=0;

    while(!Q.empty()){
        int x = Q.front() %5;
        int y = Q.front() /5;
        Q.pop();
        if(MAP[y][x]==0){
            cnt++;
        }
        for(int i=1; i<7; i++){
            for(int d=0; d<4; d++){
                if(x+dx[d]==(seven[i]%5) && y+dy[d]==(seven[i]/5)
                   && check[i]==false){
                    check[i]=true;
                    Q.push(seven[i]);
                }
            }
        }
    }
    while(!Q.empty()){ //초기화
        Q.pop();
    }
    for(int k=0; k<7; k++){
        if(check[k] == false){
            return;
        }
    }
    if(cnt >= 4){
        sol++;
    }
    
}
void dfs(int depth,int selected){
    if(depth<26){
        if(selected==7){
            cal();
        }else{
            seven.push_back(depth);
            dfs(depth+1, selected+1);
            seven.pop_back();
            dfs(depth+1, selected);
        }
    }
}
int main(){
    string temp_str;
    for(int r=0; r<5; r++){
        cin >> temp_str;
        for(int c=0; c<5; c++){
            if(temp_str[c]=='Y'){
                MAP[r][c]=1;
            }else if(temp_str[c]=='S'){
                MAP[r][c]=0;
            }
        }
    }
    dfs(0,0);
    cout << sol;
    return 0;
}